//! Shared lemma cache for cross-engine lemmatization
//!
//! This module provides a thread-safe cache for storing lemmatization results from multiple
//! sources (UD gold standard, SimpleLemmatizer, etc.) with priority-based lookup.

use lru::LruCache;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::num::NonZeroUsize;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use tracing::{debug, info};

/// Source of a lemmatization result
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum LemmaSource {
    /// Gold-standard lemma from Universal Dependencies treebank
    UDGold,
    /// Generated by SimpleLemmatizer
    SimpleLemmatizer,
    /// Synthesized from VerbNet/FrameNet patterns
    Synthesized,
    /// Learned from validation against gold standard
    Learned,
    /// External lemmatizer (e.g., nlprule)
    External,
}

impl LemmaSource {
    /// Get priority for lemma source (higher = more trusted)
    pub fn priority(&self) -> u8 {
        match self {
            LemmaSource::UDGold => 100,
            LemmaSource::Learned => 80,
            LemmaSource::External => 70,
            LemmaSource::SimpleLemmatizer => 50,
            LemmaSource::Synthesized => 30,
        }
    }

    /// Check if this source should override another source
    pub fn should_override(&self, other: &LemmaSource) -> bool {
        self.priority() > other.priority()
    }
}

impl std::fmt::Display for LemmaSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LemmaSource::UDGold => write!(f, "UD_gold"),
            LemmaSource::SimpleLemmatizer => write!(f, "SimpleLemmatizer"),
            LemmaSource::Synthesized => write!(f, "synthesized"),
            LemmaSource::Learned => write!(f, "learned"),
            LemmaSource::External => write!(f, "external"),
        }
    }
}

/// Cached lemma entry with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LemmaEntry {
    /// The lemmatized form
    pub lemma: String,
    /// Source of the lemmatization
    pub source: LemmaSource,
    /// Confidence score (0.0 - 1.0)
    pub confidence: f32,
    /// When this entry was created (as seconds since creation)
    #[serde(skip, default = "Instant::now")]
    pub timestamp: Instant,
    /// How many times this entry was accessed
    pub access_count: u32,
}

impl LemmaEntry {
    /// Create a new lemma entry
    pub fn new(lemma: String, source: LemmaSource, confidence: f32) -> Self {
        Self {
            lemma,
            source,
            confidence,
            timestamp: Instant::now(),
            access_count: 0,
        }
    }

    /// Mark this entry as accessed
    pub fn mark_accessed(&mut self) {
        self.access_count += 1;
    }

    /// Check if entry is expired (older than TTL)
    pub fn is_expired(&self, ttl: Duration) -> bool {
        self.timestamp.elapsed() > ttl
    }
}

/// Configuration for lemma cache
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LemmaCacheConfig {
    /// Maximum number of entries in cache
    pub max_entries: usize,
    /// Time-to-live for entries
    pub ttl: Duration,
    /// Minimum confidence to cache
    pub min_confidence: f32,
    /// Enable cache metrics
    pub enable_metrics: bool,
}

impl Default for LemmaCacheConfig {
    fn default() -> Self {
        Self {
            max_entries: 10_000,
            ttl: Duration::from_secs(3600), // 1 hour
            min_confidence: 0.1,
            enable_metrics: true,
        }
    }
}

/// Cache statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LemmaCacheStats {
    /// Total cache hits
    pub hits: u64,
    /// Total cache misses
    pub misses: u64,
    /// Number of entries added
    pub insertions: u64,
    /// Number of entries evicted
    pub evictions: u64,
    /// Number of entries expired
    pub expirations: u64,
    /// Hits by source
    pub hits_by_source: HashMap<String, u64>,
}

impl LemmaCacheStats {
    /// Calculate hit rate
    pub fn hit_rate(&self) -> f64 {
        if self.hits + self.misses == 0 {
            0.0
        } else {
            self.hits as f64 / (self.hits + self.misses) as f64
        }
    }

    /// Get total requests
    pub fn total_requests(&self) -> u64 {
        self.hits + self.misses
    }
}

/// Thread-safe shared lemma cache
pub struct LemmaCache {
    /// LRU cache for lemma entries
    cache: Arc<Mutex<LruCache<String, LemmaEntry>>>,
    /// Cache configuration
    config: LemmaCacheConfig,
    /// Cache statistics
    stats: Arc<Mutex<LemmaCacheStats>>,
}

impl LemmaCache {
    /// Create a new lemma cache
    pub fn new(config: LemmaCacheConfig) -> Self {
        let cache_size =
            NonZeroUsize::new(config.max_entries).expect("Cache size must be greater than 0");

        Self {
            cache: Arc::new(Mutex::new(LruCache::new(cache_size))),
            config,
            stats: Arc::new(Mutex::new(LemmaCacheStats::default())),
        }
    }

    /// Get lemma from cache
    pub fn get(&self, word: &str) -> Option<LemmaEntry> {
        let mut cache = self.cache.lock().unwrap();
        let mut stats = self.stats.lock().unwrap();

        if let Some(entry) = cache.get_mut(word) {
            // Check if entry is expired
            if entry.is_expired(self.config.ttl) {
                cache.pop(word);
                stats.expirations += 1;
                stats.misses += 1;
                return None;
            }

            entry.mark_accessed();
            stats.hits += 1;

            if self.config.enable_metrics {
                *stats
                    .hits_by_source
                    .entry(entry.source.to_string())
                    .or_insert(0) += 1;
            }

            debug!(
                "Cache hit for '{}': {} ({})",
                word, entry.lemma, entry.source
            );
            Some(entry.clone())
        } else {
            stats.misses += 1;
            debug!("Cache miss for '{}'", word);
            None
        }
    }

    /// Insert lemma into cache
    pub fn insert(&self, word: String, lemma: String, source: LemmaSource, confidence: f32) {
        // Don't cache low-confidence entries
        if confidence < self.config.min_confidence {
            return;
        }

        let mut cache = self.cache.lock().unwrap();
        let mut stats = self.stats.lock().unwrap();

        // Check if we should override existing entry
        if let Some(existing) = cache.peek(&word) {
            if !source.should_override(&existing.source) {
                debug!(
                    "Not overriding {} with lower priority source {}",
                    existing.source, source
                );
                return;
            }
        }

        let entry = LemmaEntry::new(lemma.clone(), source, confidence);

        if cache.put(word.clone(), entry).is_some() {
            stats.evictions += 1;
        }

        stats.insertions += 1;
        debug!(
            "Cached '{}' -> '{}' from {} (confidence: {:.2})",
            word, lemma, source, confidence
        );
    }

    /// Insert with convenience method for word -> lemma mapping
    pub fn insert_simple(&self, word: &str, lemma: &str, source: LemmaSource) {
        self.insert(word.to_string(), lemma.to_string(), source, 1.0);
    }

    /// Bulk insert from HashMap
    pub fn insert_bulk(
        &self,
        mappings: HashMap<String, String>,
        source: LemmaSource,
        confidence: f32,
    ) {
        for (word, lemma) in mappings {
            self.insert(word, lemma, source, confidence);
        }
    }

    /// Clear all entries
    pub fn clear(&self) {
        let mut cache = self.cache.lock().unwrap();
        cache.clear();
        info!("Lemma cache cleared");
    }

    /// Get cache statistics
    pub fn stats(&self) -> LemmaCacheStats {
        self.stats.lock().unwrap().clone()
    }

    /// Get current cache size
    pub fn len(&self) -> usize {
        self.cache.lock().unwrap().len()
    }

    /// Check if cache is empty
    pub fn is_empty(&self) -> bool {
        self.cache.lock().unwrap().is_empty()
    }

    /// Get memory usage estimate in bytes
    pub fn memory_usage(&self) -> usize {
        let cache = self.cache.lock().unwrap();
        let entry_size = std::mem::size_of::<LemmaEntry>() + 50; // Estimate for strings
        cache.len() * entry_size
    }

    /// Cleanup expired entries
    pub fn cleanup_expired(&self) {
        let mut cache = self.cache.lock().unwrap();
        let mut stats = self.stats.lock().unwrap();
        let mut expired_keys = Vec::new();

        // Collect expired keys (can't remove while iterating)
        for (key, entry) in cache.iter() {
            if entry.is_expired(self.config.ttl) {
                expired_keys.push(key.clone());
            }
        }

        // Remove expired entries
        for key in expired_keys {
            cache.pop(&key);
            stats.expirations += 1;
        }

        if stats.expirations > 0 {
            info!(
                "Cleaned up {} expired lemma cache entries",
                stats.expirations
            );
        }
    }
}

impl Clone for LemmaCache {
    fn clone(&self) -> Self {
        Self {
            cache: self.cache.clone(),
            config: self.config.clone(),
            stats: self.stats.clone(),
        }
    }
}

impl Default for LemmaCache {
    fn default() -> Self {
        Self::new(LemmaCacheConfig::default())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_lemma_source_priority() {
        assert!(LemmaSource::UDGold.priority() > LemmaSource::SimpleLemmatizer.priority());
        assert!(LemmaSource::Learned.priority() > LemmaSource::Synthesized.priority());
        assert!(LemmaSource::UDGold.should_override(&LemmaSource::SimpleLemmatizer));
        assert!(!LemmaSource::Synthesized.should_override(&LemmaSource::UDGold));
    }

    #[test]
    fn test_lemma_entry() {
        let mut entry = LemmaEntry::new("run".to_string(), LemmaSource::UDGold, 0.95);
        assert_eq!(entry.lemma, "run");
        assert_eq!(entry.source, LemmaSource::UDGold);
        assert_eq!(entry.confidence, 0.95);
        assert_eq!(entry.access_count, 0);

        entry.mark_accessed();
        assert_eq!(entry.access_count, 1);
    }

    #[test]
    fn test_lemma_cache_basic_operations() {
        let cache = LemmaCache::default();

        // Test miss
        assert!(cache.get("running").is_none());

        // Test insert and hit
        cache.insert_simple("running", "run", LemmaSource::SimpleLemmatizer);
        let entry = cache.get("running").unwrap();
        assert_eq!(entry.lemma, "run");
        assert_eq!(entry.source, LemmaSource::SimpleLemmatizer);

        // Test stats
        let stats = cache.stats();
        assert_eq!(stats.hits, 1);
        assert_eq!(stats.misses, 1);
        assert_eq!(stats.insertions, 1);
    }

    #[test]
    fn test_cache_priority_override() {
        let cache = LemmaCache::default();

        // Insert lower priority entry
        cache.insert_simple("running", "run1", LemmaSource::Synthesized);
        assert_eq!(cache.get("running").unwrap().lemma, "run1");

        // Higher priority should override
        cache.insert_simple("running", "run2", LemmaSource::UDGold);
        assert_eq!(cache.get("running").unwrap().lemma, "run2");

        // Lower priority should not override
        cache.insert_simple("running", "run3", LemmaSource::SimpleLemmatizer);
        assert_eq!(cache.get("running").unwrap().lemma, "run2"); // Still the UD gold
    }

    #[test]
    fn test_cache_expiration() {
        let config = LemmaCacheConfig {
            ttl: Duration::from_millis(10),
            ..Default::default()
        };
        let cache = LemmaCache::new(config);

        cache.insert_simple("test", "test", LemmaSource::SimpleLemmatizer);
        assert!(cache.get("test").is_some());

        // Wait for expiration
        thread::sleep(Duration::from_millis(20));

        // Should be expired now
        assert!(cache.get("test").is_none());
        assert_eq!(cache.stats().expirations, 1);
    }

    #[test]
    fn test_bulk_insert() {
        let cache = LemmaCache::default();
        let mut mappings = HashMap::new();
        mappings.insert("running".to_string(), "run".to_string());
        mappings.insert("walking".to_string(), "walk".to_string());

        cache.insert_bulk(mappings, LemmaSource::Learned, 0.8);

        assert_eq!(cache.get("running").unwrap().lemma, "run");
        assert_eq!(cache.get("walking").unwrap().lemma, "walk");
        assert_eq!(cache.stats().insertions, 2);
    }

    #[test]
    fn test_min_confidence_filtering() {
        let config = LemmaCacheConfig {
            min_confidence: 0.5,
            ..Default::default()
        };
        let cache = LemmaCache::new(config);

        // Low confidence should not be cached
        cache.insert(
            "test1".to_string(),
            "test1".to_string(),
            LemmaSource::Synthesized,
            0.3,
        );
        assert!(cache.get("test1").is_none());

        // High confidence should be cached
        cache.insert(
            "test2".to_string(),
            "test2".to_string(),
            LemmaSource::Synthesized,
            0.8,
        );
        assert!(cache.get("test2").is_some());
    }

    #[test]
    fn test_cleanup_expired() {
        let config = LemmaCacheConfig {
            ttl: Duration::from_millis(10),
            ..Default::default()
        };
        let cache = LemmaCache::new(config);

        cache.insert_simple("test1", "test1", LemmaSource::SimpleLemmatizer);
        cache.insert_simple("test2", "test2", LemmaSource::SimpleLemmatizer);
        assert_eq!(cache.len(), 2);

        // Wait for expiration
        thread::sleep(Duration::from_millis(20));

        // Cleanup
        cache.cleanup_expired();
        assert_eq!(cache.len(), 0);
    }
}
