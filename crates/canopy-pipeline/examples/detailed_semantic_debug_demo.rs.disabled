//! Detailed Semantic Analysis Debug Demo
//!
//! Shows comprehensive semantic analysis with detailed logging for debugging
//! the entire semantic pipeline across all engines.

use canopy_pipeline::create_l1_analyzer;
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    // Initialize logging (info level for clean output)
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .with_target(false)
        .init();

    println!("ğŸ”¬ Detailed Semantic Analysis Debug Demo");
    println!("========================================\n");

    // Create analyzer with detailed logging
    println!("ğŸš€ Initializing L1 Semantic Analyzer...");
    let analyzer = create_l1_analyzer()?;

    let stats = analyzer.get_statistics();
    println!("âœ… Analyzer ready:");
    println!("   ğŸ¯ Active engines: {:?}", stats.active_engines);
    println!(
        "   ğŸ’¾ Cache: {:.1}% hit rate, {:.1}MB used",
        stats.cache_hit_rate * 100.0,
        stats.memory_usage.estimated_usage_mb
    );
    println!(
        "   âš¡ Parallel processing: {:.1}% of queries",
        stats.parallel_query_rate * 100.0
    );
    println!();

    // Test cases with rich linguistic diversity
    let test_cases = [
        // Simple verbs with clear argument structure
        ("give", "ğŸ Ditransitive verb with Agent/Theme/Beneficiary"),
        ("break", "ğŸ’¥ Causative verb with Agent/Patient"),
        ("run", "ğŸƒ Motion verb with Agent/Path"),
        ("think", "ğŸ§  Mental state verb with Experiencer/Theme"),
        // Complex verbs with multiple senses
        ("take", "âœ‹ Highly polysemous verb (possession/motion/time)"),
        ("make", "ğŸ”¨ Creation/causation verb with multiple frames"),
        ("get", "ğŸ“¥ Acquisition/change-of-state verb"),
        // Nouns with rich semantic hierarchies
        ("teacher", "ğŸ‘©â€ğŸ« Agent noun (person who teaches)"),
        ("knowledge", "ğŸ“š Abstract concept with complex semantics"),
        ("building", "ğŸ¢ Concrete entity with multiple senses"),
        ("computer", "ğŸ’» Artifact with technological domain"),
        // Adjectives with different semantic types
        ("beautiful", "âœ¨ Aesthetic evaluative adjective"),
        ("angry", "ğŸ˜  Emotional state adjective"),
        ("wooden", "ğŸªµ Material composition adjective"),
        ("intelligent", "ğŸ§  Cognitive ability adjective"),
        // Challenging cases
        (
            "bank",
            "ğŸ¦ Highly ambiguous (financial institution/river edge)",
        ),
        ("fly", "ğŸª° Verb/noun ambiguity (action vs. insect)"),
        ("cold", "ğŸ¥¶ Temperature/emotional state polysemy"),
    ];

    for (word, description) in test_cases {
        println!("ğŸ” ANALYZING: \"{}\" {}", word, description);
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        let start = std::time::Instant::now();
        let result = analyzer.analyze(word)?;
        let analysis_time = start.elapsed();

        // Overall results summary
        println!("ğŸ“Š RESULTS SUMMARY:");
        println!(
            "   â±ï¸  Analysis time: {:.2}ms",
            analysis_time.as_micros() as f64 / 1000.0
        );
        println!("   ğŸ¯ Sources found: {} engines", result.sources.len());
        println!(
            "   ğŸ”— Unified roles: {}",
            result.unified_semantic_roles.len()
        );
        println!("   ğŸ“ˆ Overall confidence: {:.3}", result.confidence);
        println!(
            "   ğŸ—ï¸  Semantic hierarchies: {}",
            result.semantic_hierarchies.len()
        );

        // Detailed per-engine breakdown
        println!("\nğŸ“‹ PER-ENGINE ANALYSIS:");

        // VerbNet analysis
        if let Some(verbnet) = &result.verbnet {
            println!("   ğŸ·ï¸  VerbNet:");
            println!("      ğŸ“ Verb classes: {}", verbnet.verb_classes.len());
            println!(
                "      ğŸ­ Theta roles: {}",
                verbnet.theta_role_assignments.len()
            );
            for (i, class) in verbnet.verb_classes.iter().enumerate().take(3) {
                println!(
                    "      â””â”€ Class {}: {} ({})",
                    i + 1,
                    class.id,
                    class.class_name
                );
                if !class.themroles.is_empty() {
                    println!(
                        "         Roles: {:?}",
                        class.themroles.iter().take(3).collect::<Vec<_>>()
                    );
                }
            }
            if verbnet.verb_classes.len() > 3 {
                println!(
                    "      â””â”€ ... and {} more classes",
                    verbnet.verb_classes.len() - 3
                );
            }
        } else {
            println!("   ğŸ·ï¸  VerbNet: No data found");
        }

        // FrameNet analysis
        if let Some(framenet) = &result.framenet {
            println!("   ğŸ–¼ï¸  FrameNet:");
            println!("      ğŸª Frames: {}", framenet.frames.len());
            println!("      ğŸ“ Lexical units: {}", framenet.lexical_units.len());
            for (i, frame) in framenet.frames.iter().enumerate().take(3) {
                println!("      â””â”€ Frame {}: {} ({})", i + 1, frame.name, frame.id);
                if !frame.frame_elements.is_empty() {
                    let elements: Vec<String> = frame
                        .frame_elements
                        .iter()
                        .take(3)
                        .map(|fe| format!("{}:{:?}", fe.name, fe.core_type))
                        .collect();
                    println!("         Elements: [{}]", elements.join(", "));
                }
            }
            if framenet.frames.len() > 3 {
                println!("      â””â”€ ... and {} more frames", framenet.frames.len() - 3);
            }
        } else {
            println!("   ğŸ–¼ï¸  FrameNet: No data found");
        }

        // WordNet analysis
        if let Some(wordnet) = &result.wordnet {
            println!("   ğŸ“š WordNet:");
            println!("      ğŸ“– Synsets: {}", wordnet.synsets.len());
            println!("      ğŸ”— Relations: {}", wordnet.relations.len());
            for (i, synset) in wordnet.synsets.iter().enumerate().take(3) {
                println!(
                    "      â””â”€ Synset {}: {:?} - {}",
                    i + 1,
                    synset.pos,
                    synset.definition().chars().take(50).collect::<String>()
                );
            }
            if wordnet.synsets.len() > 3 {
                println!(
                    "      â””â”€ ... and {} more synsets",
                    wordnet.synsets.len() - 3
                );
            }
        } else {
            println!("   ğŸ“š WordNet: No data found");
        }

        // Lexicon analysis
        if let Some(lexicon) = &result.lexicon {
            println!("   ğŸ“– Lexicon:");
            println!(
                "      ğŸ“ Classifications: {}",
                lexicon.classifications.len()
            );
            println!(
                "      ğŸ”¤ Pattern matches: {}",
                lexicon.pattern_matches.len()
            );
            if !lexicon.classifications.is_empty() {
                println!(
                    "      â””â”€ Classifications: {:?}",
                    lexicon.classifications.iter().take(3).collect::<Vec<_>>()
                );
            }
        } else {
            println!("   ğŸ“– Lexicon: No data found");
        }

        // Unified semantic roles (cross-engine integration)
        if !result.unified_semantic_roles.is_empty() {
            println!("\nğŸ”— UNIFIED SEMANTIC ROLES:");
            for (i, role) in result.unified_semantic_roles.iter().enumerate().take(5) {
                println!(
                    "   {}. {} (confidence: {:.3})",
                    i + 1,
                    role.role_name,
                    role.confidence
                );
                if let Some(vn_role) = &role.verbnet_theta_role {
                    println!("      ğŸ·ï¸  VerbNet: {:?}", vn_role);
                }
                if let Some(fn_element) = &role.framenet_element {
                    println!("      ğŸ–¼ï¸  FrameNet: {}", fn_element);
                }
                if let Some(pos) = role.argument_position {
                    println!(
                        "      ğŸ“ Position: {}, Compatibility: {:.3}",
                        pos, role.compatibility_score
                    );
                }
            }
            if result.unified_semantic_roles.len() > 5 {
                println!(
                    "   â””â”€ ... and {} more unified roles",
                    result.unified_semantic_roles.len() - 5
                );
            }
        }

        // Semantic hierarchies
        if !result.semantic_hierarchies.is_empty() {
            println!("\nğŸ—ï¸  SEMANTIC HIERARCHIES:");
            for (i, hierarchy) in result.semantic_hierarchies.iter().enumerate().take(3) {
                println!(
                    "   {}. {} (parents: {}, children: {})",
                    i + 1,
                    hierarchy.concept,
                    hierarchy.parents.len(),
                    hierarchy.children.len()
                );
                println!(
                    "      Source: {}, Siblings: {}",
                    hierarchy.source,
                    hierarchy.siblings.len()
                );
            }
            if result.semantic_hierarchies.len() > 3 {
                println!(
                    "   â””â”€ ... and {} more hierarchies",
                    result.semantic_hierarchies.len() - 3
                );
            }
        }

        println!("\nğŸ’¡ SEMANTIC INSIGHTS:");
        if result.sources.len() >= 4 {
            println!("   âœ… Rich semantic coverage across all engines");
        } else if result.sources.len() >= 2 {
            println!("   âš ï¸  Partial coverage - some engines have no data");
        } else {
            println!("   âŒ Poor coverage - most engines lack data for this word");
        }

        if result.unified_semantic_roles.len() > 0 {
            println!("   ğŸ”— Cross-engine role alignment successful");
        } else if result.verbnet.is_some() || result.framenet.is_some() {
            println!("   ğŸ” Individual engine data found but no role unification");
        }

        if result.confidence > 0.8 {
            println!("   ğŸ¯ High confidence analysis");
        } else if result.confidence > 0.5 {
            println!("   âš–ï¸  Moderate confidence analysis");
        } else {
            println!("   âš ï¸  Low confidence - results may be unreliable");
        }

        println!("\n{}\n", "â”€".repeat(80));
    }

    // Final system statistics
    let final_stats = analyzer.get_statistics();
    println!("ğŸ“ˆ FINAL SYSTEM STATISTICS:");
    println!(
        "   ğŸ’¾ Cache performance: {:.1}% hit rate",
        final_stats.cache_hit_rate * 100.0
    );
    println!(
        "   âš¡ Parallel processing: {:.1}% of queries used parallel execution",
        final_stats.parallel_query_rate * 100.0
    );
    println!(
        "   ğŸ§  Memory usage: {:.1}MB total ({:.1}% of budget)",
        final_stats.memory_usage.estimated_usage_mb, final_stats.memory_usage.utilization_percent
    );
    println!(
        "   ğŸ¯ Engine coverage: {} active engines",
        final_stats.active_engines.len()
    );

    Ok(())
}
