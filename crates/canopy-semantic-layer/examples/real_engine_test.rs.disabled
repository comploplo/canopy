//! Real Engine Integration Test
//!
//! This example tests the real VerbNet, FrameNet, WordNet, and Lexicon engines
//! through the SemanticCoordinator to verify they're working for real.

use canopy_semantic_layer::{coordinator::CoordinatorConfig, SemanticCoordinator};
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    // Initialize tracing for debug output
    tracing_subscriber::fmt::init();

    println!("ðŸ§ª Testing Real Semantic Engines");
    println!("=================================");

    // Test with real engines enabled (graceful degradation for missing data)
    let config = CoordinatorConfig {
        enable_verbnet: true,
        enable_framenet: true,
        enable_wordnet: true,
        enable_lexicon: true,
        graceful_degradation: true, // Continue even if some engines fail to load
        confidence_threshold: 0.1,
        l1_cache_memory_mb: 50, // Small cache for testing
        ..CoordinatorConfig::default()
    };

    println!("ðŸ—ï¸  Initializing SemanticCoordinator with real engines...");
    let coordinator = match SemanticCoordinator::new(config) {
        Ok(coord) => {
            println!("âœ… SemanticCoordinator initialized successfully");
            coord
        }
        Err(e) => {
            println!("âŒ Failed to initialize SemanticCoordinator: {}", e);
            println!("ðŸ’¡ This might be because VerbNet/FrameNet XML data is not available");
            return Ok(());
        }
    };

    // Get initial statistics
    let initial_stats = coordinator.get_statistics();
    println!("\nðŸ“Š Initial Statistics:");
    println!("   Active engines: {:?}", initial_stats.active_engines);
    println!(
        "   Cache budget: {}MB",
        initial_stats.memory_usage.budget_mb
    );
    println!();

    // Test words that should have semantic data
    let test_words = vec![
        "give", "run", "walk", "eat", "break", "hello", // Should have minimal semantic data
    ];

    println!("ðŸ” Testing Semantic Analysis:");
    println!("=============================");

    for word in test_words {
        println!("\nðŸ“ Analyzing: \"{}\"", word);

        match coordinator.analyze(word) {
            Ok(result) => {
                println!("âœ… Analysis successful!");
                println!("   Sources: {:?}", result.sources);
                println!("   Confidence: {:.3}", result.confidence);
                println!("   Processing time: {}Î¼s", result.processing_time_us);

                // Show VerbNet results
                if let Some(ref verbnet) = result.verbnet {
                    println!("   ðŸ·ï¸  VerbNet: {} results", verbnet.verb_classes.len());
                    for class in &verbnet.verb_classes {
                        println!("      Class: {}", class.id);
                    }
                }

                // Show FrameNet results
                if let Some(ref framenet) = result.framenet {
                    println!("   ðŸ–¼ï¸  FrameNet: {} frames", framenet.frames.len());
                    for frame in &framenet.frames {
                        println!("      Frame: {}", frame.name);
                    }
                }

                // Show WordNet results
                if let Some(ref wordnet) = result.wordnet {
                    println!("   ðŸ“š WordNet: {} synsets", wordnet.synsets.len());
                    for synset in &wordnet.synsets {
                        println!("      Synset: {} - {}", synset.offset, synset.definition());
                    }
                }

                // Show Lexicon results
                if let Some(ref lexicon) = result.lexicon {
                    println!(
                        "   ðŸ“– Lexicon: {} classifications",
                        lexicon.classifications.len()
                    );
                    for classification in &lexicon.classifications {
                        println!("      Classification: {:?}", classification);
                    }
                }

                // Show any errors
                if !result.errors.is_empty() {
                    println!("   âš ï¸  Errors:");
                    for error in &result.errors {
                        println!("      {}", error);
                    }
                }
            }
            Err(e) => {
                println!("âŒ Analysis failed: {}", e);
            }
        }
    }

    // Test batch analysis
    println!("\nðŸ”„ Testing Batch Analysis:");
    println!("===========================");

    let batch_words = vec!["give".to_string(), "take".to_string(), "make".to_string()];

    match coordinator.analyze_batch(&batch_words) {
        Ok(results) => {
            println!("âœ… Batch analysis successful for {} words", results.len());
            for (i, result) in results.iter().enumerate() {
                println!(
                    "   {}: {} sources, conf: {:.3}",
                    batch_words[i],
                    result.sources.len(),
                    result.confidence
                );
            }
        }
        Err(e) => {
            println!("âŒ Batch analysis failed: {}", e);
        }
    }

    // Final statistics
    let final_stats = coordinator.get_statistics();
    println!("\nðŸ“Š Final Statistics:");
    println!("   Total queries: {}", final_stats.total_queries);
    println!("   Cache hits: {}", final_stats.cache_hits);
    println!(
        "   Cache hit rate: {:.1}%",
        final_stats.cache_hit_rate * 100.0
    );
    println!(
        "   Memory usage: {:.1}MB / {}MB ({:.1}%)",
        final_stats.memory_usage.estimated_usage_mb,
        final_stats.memory_usage.budget_mb,
        final_stats.memory_usage.utilization_percent
    );

    println!("\nðŸŽ¯ Test Results:");

    if final_stats.active_engines.is_empty() {
        println!("âŒ No engines were successfully loaded");
        println!("ðŸ’¡ This is expected if VerbNet/FrameNet XML data files are not available");
        println!("ðŸ“ Expected data locations:");
        println!("   - VerbNet: data/verbnet/verbnet3.4/*.xml");
        println!("   - FrameNet: data/framenet/frames/*.xml");
        println!("   - WordNet: standard installation or data files");
        println!("   - Lexicon: data/lexicon/*.xml");
    } else {
        println!(
            "âœ… Successfully loaded engines: {:?}",
            final_stats.active_engines
        );
        println!("ðŸš€ Real semantic analysis is working!");

        if final_stats.cache_hits > 0 {
            println!(
                "ðŸ’¾ Caching is working: {:.1}% hit rate",
                final_stats.cache_hit_rate * 100.0
            );
        }
    }

    Ok(())
}
