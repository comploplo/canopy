//! Real vs Stub Parser Comparison
//!
//! This test demonstrates the difference between:
//! 1. Current stub implementations (fast but fake)
//! 2. Real semantic parser implementations (slower but accurate)

use canopy_framenet::FrameNetEngine as RealFrameNetEngine;
use canopy_semantic_layer::{coordinator::CoordinatorConfig, SemanticCoordinator};
use canopy_verbnet::VerbNetEngine as RealVerbNetEngine;
use canopy_wordnet::WordNetEngine as RealWordNetEngine;
use std::error::Error;
use std::time::Instant;

fn main() -> Result<(), Box<dyn Error>> {
    println!("ğŸ•µï¸ Real vs Stub Parser Comparison");
    println!("==================================");

    // Test words
    let test_words = vec![
        "run", "walk", "love", "give", "take", "break", "eat", "sleep",
    ];

    println!(
        "\nğŸ“Š Testing {} words with both implementations...",
        test_words.len()
    );

    // === Test 1: Current Stub Implementation ===
    println!("\n1ï¸âƒ£ Current SemanticCoordinator (Stub Implementation):");
    println!("---------------------------------------------------");

    let config = CoordinatorConfig {
        confidence_threshold: 0.01,
        enable_verbnet: true,
        enable_framenet: true,
        enable_wordnet: true,
        enable_lexicon: true,
        ..CoordinatorConfig::default()
    };

    let coordinator = SemanticCoordinator::new(config)?;

    let start = Instant::now();
    let mut stub_results = Vec::new();

    for word in &test_words {
        match coordinator.analyze(word) {
            Ok(result) => {
                stub_results.push((word, result));
                println!(
                    "   {} â†’ {} sources: {:?}",
                    word,
                    result.sources.len(),
                    result.sources
                );
            }
            Err(e) => println!("   {} â†’ ERROR: {}", word, e),
        }
    }

    let stub_duration = start.elapsed();
    let stub_stats = coordinator.get_statistics();

    println!(
        "   âš¡ Stub Performance: {:.0} words/sec",
        test_words.len() as f64 / stub_duration.as_secs_f64()
    );
    println!(
        "   ğŸ“Š Cache hit rate: {:.1}%",
        stub_stats.cache_hit_rate * 100.0
    );

    // === Test 2: Real Parser Implementation ===
    println!("\n2ï¸âƒ£ Real Semantic Parsers (Full Implementation):");
    println!("----------------------------------------------");

    // Try to initialize real parsers
    println!("   ğŸ—ï¸  Attempting to load real parsers...");

    // VerbNet
    let verbnet_result = match RealVerbNetEngine::new() {
        Ok(engine) => {
            println!("   âœ… VerbNet: Real engine loaded successfully");
            Some(engine)
        }
        Err(e) => {
            println!("   âŒ VerbNet: Failed to load real data - {}", e);
            None
        }
    };

    // FrameNet
    let framenet_result = match RealFrameNetEngine::new() {
        Ok(engine) => {
            println!("   âœ… FrameNet: Real engine loaded successfully");
            Some(engine)
        }
        Err(e) => {
            println!("   âŒ FrameNet: Failed to load real data - {}", e);
            None
        }
    };

    // WordNet
    let wordnet_config = canopy_wordnet::WordNetConfig::default();
    let wordnet_result = match RealWordNetEngine::new(wordnet_config) {
        Ok(engine) => {
            println!("   âœ… WordNet: Real engine loaded successfully");
            Some(engine)
        }
        Err(e) => {
            println!("   âŒ WordNet: Failed to load real data - {}", e);
            None
        }
    };

    if verbnet_result.is_none() && framenet_result.is_none() && wordnet_result.is_none() {
        println!("\n   ğŸš¨ CRITICAL: No real parsers available!");
        println!("   ğŸ“ Expected data locations:");
        println!("      - VerbNet: data/verbnet/verbnet3.4/*.xml");
        println!("      - FrameNet: data/framenet/*.xml");
        println!("      - WordNet: system WordNet installation");
        println!("\n   â„¹ï¸  This explains why performance is so high - we're only using stubs!");
    } else {
        // Test real parsers if available
        println!("\n   ğŸ” Testing available real parsers:");

        let start = Instant::now();
        let mut real_results = Vec::new();

        for word in &test_words {
            let mut sources = Vec::new();

            if let Some(ref engine) = verbnet_result {
                match engine.analyze(word) {
                    Ok(_) => sources.push("VerbNet-Real"),
                    Err(_) => {}
                }
            }

            if let Some(ref engine) = framenet_result {
                match engine.analyze(word) {
                    Ok(_) => sources.push("FrameNet-Real"),
                    Err(_) => {}
                }
            }

            if let Some(ref engine) = wordnet_result {
                match engine.analyze(word) {
                    Ok(_) => sources.push("WordNet-Real"),
                    Err(_) => {}
                }
            }

            real_results.push((word, sources.clone()));
            println!("   {} â†’ {} sources: {:?}", word, sources.len(), sources);
        }

        let real_duration = start.elapsed();
        println!(
            "   âš¡ Real Performance: {:.0} words/sec",
            test_words.len() as f64 / real_duration.as_secs_f64()
        );

        // Compare results
        println!("\nğŸ” Result Quality Comparison:");
        println!("============================");

        for (i, word) in test_words.iter().enumerate() {
            let stub_sources = &stub_results[i].1.sources;
            let real_sources = &real_results[i].1;

            println!("   {}:", word);
            println!(
                "      Stub: {} sources â†’ {:?}",
                stub_sources.len(),
                stub_sources
            );
            println!(
                "      Real: {} sources â†’ {:?}",
                real_sources.len(),
                real_sources
            );

            if real_sources.is_empty() && !stub_sources.is_empty() {
                println!("      âš ï¸  Stub claims results but real parsers find none!");
            } else if real_sources.len() > stub_sources.len() {
                println!("      âœ… Real parsers provide richer analysis");
            }
        }
    }

    // === Analysis and Recommendations ===
    println!("\nğŸ’¡ Analysis & Recommendations:");
    println!("==============================");

    println!("   ğŸ“Š Current Status:");
    println!(
        "      â€¢ Stub Performance: {:.0} words/sec",
        test_words.len() as f64 / stub_duration.as_secs_f64()
    );
    println!("      â€¢ Using hardcoded test data (not real semantic analysis)");
    println!("      â€¢ Cache effectiveness is on trivial lookups");

    println!("\n   ğŸ¯ To Get Real Performance Numbers:");
    println!("      1. Populate VerbNet XML data in data/verbnet/verbnet3.4/");
    println!("      2. Populate FrameNet XML data in data/framenet/");
    println!("      3. Install/configure WordNet database");
    println!("      4. Update SemanticCoordinator to use real engines");

    println!("\n   âš ï¸  Expected Impact of Real Parsers:");
    println!("      â€¢ Performance will drop significantly (XML parsing overhead)");
    println!("      â€¢ Memory usage will increase (real data structures)");
    println!("      â€¢ Results will be semantically meaningful");
    println!("      â€¢ Cache effectiveness will improve analysis quality");

    Ok(())
}
